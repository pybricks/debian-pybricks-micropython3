\documentclass[12pt, a4paper]
{article}

\usepackage[margin=2cm]{geometry}
\usepackage{svg}
\setsvg{inkscape=inkscape -z -D,svgpath=images/}
\usepackage{float}
\usepackage{amsmath}
\usepackage{todonotes}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage[]{algorithm2e}


\title{Pybricks motor control algorithms}
\author{The Pybricks authors}

% Generic macros
\providecommand{\lr}[1]{\left(#1\right)}
\providecommand{\sub}[1]{_{\text{#1}}}
\renewcommand{\sup}[1]{^{\text{#1}}}

% omega symbols
\providecommand{\w}{\omega}
\providecommand{\wt}{\w^*}
\providecommand{\wref}{\w\sub{ref}}
\providecommand{\wmax}{\w\sub{max}}

% theta symbols
\renewcommand{\th}{\theta}
\providecommand{\thref}{\th\sub{ref}}

% alpha symbols
\renewcommand{\a}{\alpha}
\providecommand{\w}{\omega}
\providecommand{\dw}{\dot{\omega}}

% vector symbols
\providecommand{\x}{\boldsymbol{x}}
\providecommand{\dx}{\dot{\boldsymbol{x}}}
\renewcommand{\u}{\boldsymbol{u}}

% matrix symbols
\providecommand{\A}{\mathbf{A}}
\providecommand{\B}{\mathbf{B}}
\providecommand{\F}{\mathbf{\Phi}}
\providecommand{\G}{\mathbf{\Gamma}}


% math
\providecommand{\minab}[2]{\min\,\lr{{#1},\,\,{#2}}}
\providecommand{\abs}[1]{\left|#1\right|}
\providecommand{\inlineadd}{\,\,+\!\!=\,\,}
\providecommand{\inlinesubtract}{\,\,-\!\!=\,\,}

%
%
% Begin Document
%
%
\begin{document}
\maketitle

\tableofcontents
\pagebreak

\section{Modeling the system}

The motors discussed in this documentation typically consist of a high-speed,
low-torque DC motor, a gear train to reduce speed and increase torque, and a
sensor to measure the rotation angle. The motor is driven by a pulse width
modulated (PWM) voltage source generated by the hub to which the motor is
connected. An example of such a motor is shown in Figure~\ref{fig:motor}.

\begin{figure}[H]
    \centering
    \includesvg[width=0.9\textwidth]{motor-components}
    \caption{A typical motor consists of a geared-down dc motor and a
    rotation sensor. \label{fig:motor}}
\end{figure}

The type and placement of the rotation sensor varies between motor designs. On
some motors, the sensor measures the output shaft rotation directly. This
allows the motor to measure an ``absolute" angle, sometimes marked directly on
the output shaft (see Figure~\ref{fig:motor}). Other motors use an incremental
encoder at some stage in the gear train, and the number of encoder pulses
is scaled with the gear ratio to estimate the relative rotation of the output
shaft.

\begin{figure}[H]
    \centering
    \includesvg[width=0.7\textwidth]{motor-model-overview}
    \caption{ Representation of the motor internals. Depending on sensor
        placement, we measure either output angle directly (right), or obtain
        an approximation by scaling down the measured dc motor angle (left) by
        the gear ratio. \label{fig:motor-model-overview}}
\end{figure}


To better understand the motor behavior, we can conceptually break down the
motors into several components, as shown Figure~\ref{fig:motor-model-overview}.
Besides the DC motor component itself, there is the idealized gear train that
scales speed and torque, gear train imperfections such as friction and slack,
and the output shaft. The external load torque and additional inertia attached
to the shaft are usually unknown.

\subsection{Simplified model representation}

For the purpose of creating a model state observer that can run on the hub, it
is beneficial to use a simplified model that does not require detailed
knowledge of unknown parameters or unknown nonlinearities. In this section,
we'll make two simplifications to the components of
Figure~\ref{fig:motor-model-overview}. First, we'll ignore the geartrain
nonidealities, thereby assuming that the geared-down DC motor angle equals the
output angle, no matter where the sensor is positioned. This reduces the
number of states we have to model and estimate.

Second, we'll include the idealized gear train inside the DC motor component,
instead of modeling them as separate components. This way, we can estimate most
motor parameters using basic speed and torque measurements without having to
disassemble motors to learn about motor and gear train characteristics.


\subsection{System state equations}

With the aforementioned simplifications, we are left with a standard DC motor
model that drives a simple inertial load, subject to external torque
disturbances, as shown in Figure~\ref{fig:motor-model-symbols}.

\begin{figure}[H]
    \centering
    \includesvg[width=0.9\textwidth]{motor-model-symbols}
    \caption{Representation of the electrical model converting a voltage into
    a torque (left), and the mechanical motor model converting a torque into
    motion (right). In this further-simplified motor model, the geartrain
    scaling effects are included in the dc motor component and geartrain
    nonidealities are omitted entirely. \label{fig:motor-model-symbols}}
\end{figure}

The hub sets the motor voltage $V$, which in turn results in the current~$i$.
The motor inductance is modeled as $L$ and the lumped resistance as $R$. The
motor back EMF is denoted $V_\text{EMF}=K_e\w$, where $\w =
\frac{d\theta}{dt}$ is the angular velocity of the motor. The motor then
behaves as:
%
\begin{align}
    \label{eq:state1}
    L\dfrac{di}{dt} + R i &= V - K_e\w \qquad \Rightarrow \qquad
    \dfrac{di}{dt} = \dfrac{1}{L}V - \dfrac{K_e}{L}\w - \dfrac{R}{L} i
\end{align}
%
The motor generates a torque $\tau_e = K_t i$ and is subject to friction and
load torques $\tau = \tau_f + \tau_l$. The net torque drives the mechanics with
a rotation angle $\th$ and total inertia $I$ as:
\begin{align}
    \label{eq:state2}
    I \dfrac{d\w}{dt} &= K_t i - \tau \qquad \Rightarrow \qquad
    \dfrac{d\w}{dt} = \dfrac{K_t}{I}i - \dfrac{1}{I}\tau
\end{align}

\subsection{Scaling the numerical inputs}

Since most of the implementation uses integer arithmetic, it is often
practical to scale signals instead of working with SI units directly. For
example, we'll represent voltages as millivolts~(mV) so that they can be
stored in a \texttt{int32\_t} variable. Currents are scaled to milliamperes (mA),
angles are scaled to millidegrees (mdeg), and torques to
microNewtonmeters ($\mu$Nm). Scaled symbols are denoted with a bar symbol as:
%
\begin{align}
    \nonumber
    \bar{\th} &= c_\th \th,&  c_\th &= 180 \,\,000 \,\pi^{-1} \, \text{(mdeg / rad)}\\[1em]
    \nonumber
    \bar{\w} &= c_\th \w,&  &\\[1em]
    \label{eq:scaling}
    \bar{\tau} &= c_\tau \tau,&   c_\tau &= 10^6 \, \text{($\mu$Nm /  Nm)} \\[1em]
    \nonumber
    \bar{V} &= c_V V,&  c_V &= 10^3 \, \text{(mV / V)} \\[1em]
    \nonumber
    \bar{i} &= c_i i,&  c_i &= 10^3 \, \text{(mA / A)}
\end{align}
%
Using these scaled signals, we define the system state vector $\x$ and input
vector $\u$ as:
%
\begin{align}
    \label{eq:states}
    \x = \begin{bmatrix}
        \bar{\th}\\[1em]
        \bar{\w}\\[1em]
        \bar{i}
    \end{bmatrix},\qquad\qquad
    \u = \begin{bmatrix}
        \bar{V}\\[1em]
        \bar{\tau}
    \end{bmatrix}
\end{align}

\subsection{System state equations}

For offline simulation and the online state observer implementation, we are
interested in the rate of change of the system state, which is defined as:
%
\begin{align}
    \label{eq:statechange1}
    \dx = f(\x, \u) = \begin{bmatrix}
        \dot{\bar{\th}}\\[1em]
        \dot{\bar{\w}}\\[1em]
        \dot{\bar{i}}
    \end{bmatrix}
\end{align}
%
where $\dot{\bar{\w}}$ follows from \eqref{eq:state2} and $\dot{\bar{i}}$
follows from \eqref{eq:state1}, after scaling with \eqref{eq:scaling}. Since
the expressions for both symbols are linear in $\x$ and $\u$, we can write
\eqref{eq:statechange1} as the linear time invariant system
\begin{align}
    \dx = \F \x + \G \u
\end{align}
%
with the constant system matrices defined as:
%
\begin{align}
    \F = \frac{\partial f(\x, \u)}{\partial \x}, \qquad
    \G = \frac{\partial f(\x, \u)}{\partial \u}
\end{align}
%
If we assume that the input $\u$ is constant for a duration $h$ between sample
instances $k$ and $k+1$, this system can also be represented by the following
discrete time model:
%
\begin{align}
    \label{eq:discretetime}
    \x(k + 1) = \A \x (k) + \B \u (k)
\end{align}
%
The system matrices $\A$ and $\B$ can be obtained from the combined matrix
exponent:
%
\begin{align}
    \begin{bmatrix}
        \A & \B \\
        \mathbf{0} & \mathbf{I}
    \end{bmatrix} = \texttt{exp} \lr{
        \begin{bmatrix}
            \F & \G \\
            \mathbf{0} & \mathbf{0}
        \end{bmatrix}h
    }
\end{align}
%
These matrices are constant in the model parameters,
which means that they can be expressed as sets of floating point values at
compile time. This way, \eqref{eq:discretetime} can be evaluated on a
microcontroller using simple floating point arithmetic.

The values are stored as scalars using the matrix indices as follows:

\begin{align}
    \A = 
    \begin{bmatrix}
        1 & a_{01} & a_{02}\\
        0 & a_{11} & a_{12}\\
        0 & a_{21} & a_{22}\\
    \end{bmatrix}\qquad
    \B = 
    \begin{bmatrix}
        b_{00} & b_{01}\\
        b_{10} & b_{11}\\
        b_{20} & b_{21}\\
    \end{bmatrix}
\end{align}


\subsection{Estimating motor parameters}

Most of the motor parameters used in the model
(\ref{eq:state1}--\ref{eq:state2}) can be estimated with reasonable accuracy
from simple experiments where the motor operates in a steady state. Typically,
the motor is run at a steady voltage, and the speed is recorded for various
known torque loads. This section shows how to derive the motor parameters from
two points on the linear torque-velocity curve.

\subsubsection{Steady state analysis}

When the motor is powered by a constant voltage $V$ and is subject to a
constant load $\tau$, the speed $\w$ and current $i$ eventually stabilize at
constant values. With $\dot{w}=0$ and
$\dot{i} = 0$, the model~(\ref{eq:state1}--\ref{eq:state2}) reduces to:
%
\begin{align}
    \label{eq:steadystate1}
    R i &= V - K_e\w\\[1em]
    \label{eq:steadystate2}
    K_t i &= \tau = \tau_a + \tau_s
\end{align}

In this simplified analysis, we assume that the load $\tau = \tau_a + \tau_s$
purely consists of the known applied torque $\tau_a$ and an unknown constant
friction torque $\tau_s$. Additional frictional torque terms that are linear
in $\w$ are effectively captured in $K_e$, since it also reduces the current
and output torque. Rewriting (\ref{eq:steadystate1}--\ref{eq:steadystate2}),
we obtain the linear relationship between the applied torque $\tau_a$ and the
measured speed $\w$ as:
\begin{align}
    \label{eq:steadystate3}
    \w &= - \dfrac{R}{K_t K_e} \lr{ \tau_a + \tau_s} + \dfrac{1}{K_e}V\\[1em]
    i &= \dfrac{1}{K_t} \lr{\tau_a + \tau_s}
\end{align}

These curves are often given for a particular voltage $V$ on a device data
sheet, or they can be determined experimentally. Usually, we have a no-load
measurement where $\tau_a = \tau_0 = 0$ results in a speed $\w_0$ and current
$i$, and a nonzero load measurement where $\tau_a = \tau_x > 0$ results in a
speed $\w_x$ and current $i_x$. The recipe for the resulting parameters
becomes:
%
\begin{align}
    \label{eq:recipe}
    K_t &:= \dfrac{\tau_x - \tau_0}{i_x - i_0}\\[1em]
    \tau_s &:= K_t i_0 -  \tau_0\\[1em]
    \dfrac{R}{K_e} &:= K_t\dfrac{\w_x - \w_0}{\tau_0 - \tau_x}\\[1em]
    K_e &:= V \lr{\w_0 + \dfrac{R}{K_t K_e} \lr{ \tau_0 + \tau_s}}^{-1}\\[1em]
    R_m &:= \dfrac{R}{K_e} K_e
\end{align}


\subsubsection{Estimating inductance and inertia}

A crude estimate of inertia can be obtained by estimating the acceleration
from zero speed at no load, while applying the rated voltage to the motor.
Because back EMF is low at low speeds, we can use \eqref{eq:state2} with
(\ref{eq:steadystate1}--\ref{eq:steadystate2}) to obtain
%
\begin{align}
    I  \approx \dfrac{\Delta t}{\Delta \w} (K_t \dfrac{V}{R} - \tau_s)
\end{align}
%
In practice, the value may be tweaked to make the motor model response to
voltage match experiments closely.

The inductance $L$ can be measured across
the motor terminals with the appropriate equipment. In turn, it can be tweaked
slightly to make simulated velocity values match measured data from
experiments with suitably varying voltage signals.

\subsection{Feedforward voltage model}

\section{Control system overview}

\begin{figure}[H]
    \centering
    \fontsize{8}{10}\selectfont
    \includesvg[inkscapelatex=false,width=1\textwidth]{control}
    \caption{
        Control system overview.
        \label{fig:controloverview}}
\end{figure}


\section{Reference trajectories}

When the user gives a motor command, we compute the reference trajectories for
the motor angle ($\thref$) and angular velocity ($\wref$) as a function of
time ($t$). These trajectories describe the ideal motion that would be followed
if the motor is not subject to external loads or disturbances.

\subsection{Trajectory definition}

For a typical maneuver, the reference trajectories for $\thref$ and $\wref$
are shown in Figure \ref{fig:plots}. Initially, when the user executes the
command at time $t_0$, the motor has a given initial angle $\th_0$ and a given
initial angular velocity $\w_0$. The motor accelerates with a magnitude
$\abs{\a_0}$ until it reaches the user-specified target angular velocity $\wt$
at time $t_1$. The target speed is maintained until it begins decelerating at
time $t_2$, in order to stop precisely at $t_3$. During this maneuver, at the
corresponding times, the motor angle reference traverses from $\th_0$ through
$\th_3$.

The reference trajectories $\thref(t)$ and $\wref(t)$ are uniquely specified by
the time instants $t_0$, $t_1$, $t_2$, $t_3$, the angles $\th_0$, $\th_1$,
$\th_2$, $\th_3$, the initial velocity $\w_0$, the target velocity $\wt$, the
final velocity $\w_3$, the acceleration $\a_0$ and deceleration $\a_2$.

Depending on which command is executed, we are given a subset of these
parameters and we have to compute the dependent variables.


\begin{figure}[H]
    \centering
    \includesvg[width=0.9\textwidth]{trajectory}
    \caption{
        Reference velocity (top) and reference angle (bottom).
        \label{fig:plots}}
\end{figure}


If these parameters are known, the trajectories $\wref(t)$ and $\thref(t)$ are
given by
%
\begin{align}
    \label{eq:wref}
    \wref(t)&=
    \begin{cases}
    \w_0 & \text{if} \quad t = t_0\\ 
    \w_0 + \a_0(t-t_0) & \text{if} \quad t < t_1\\
    \w_1=\w_2=\wt  & \text{if} \quad t_1 \leq t \leq t_2\\
    \w_2 + \a_2(t-t_2) & \text{if}\quad t_2 < t < t_3\\
    \w_3 & \text{if} \quad t = t_3
    \end{cases}\\[1em]
    \label{eq:thref}
    \thref(t)&=
    \begin{cases}
        \th_0 & \text{if} \quad t = t_0\\
        \th_0 + \w_0(t-t_0) + \dfrac{1}{2}\a_0(t-t_0)^2 &
            \text{if} \quad t_0 < t \leq t_1\\
        \th_1 + \w_1(t-t_1)  & \text{if} \quad t_1 < t \leq t_2\\
        \th_2 +\w_2(t-t_2)+\dfrac{1}{2}\a_2(t-t_2)^2 &
            \text{if}\quad t_2 < t < t_3\\
        \th_3 & \text{if} \quad t = t_3
    \end{cases}
\end{align}

Some parameters are known because they are measured or because they are
specified by the user, while others are to be computed from the known
parameters. Which of the parameters are known depends on the user-specified
maneuver.

If the user specifies to rotate the motor for a certain duration with
\texttt{run\_time(speed, duration)}, the final time $t_3=t_0+t\sub{duration}$
is known but we must compute the corresponding angle $\th_3$. If instead the
final angle $\th_3$ is specified by the user command, we have to compute the
final time $t_3$. This applies to \texttt{run\_target(speed, target)}, where
$\th_3=\th\sub{target}$. The following two sections provide the formulas to
compute the unknown parameters for both cases.


\begin{table}[H]
    \centering
    \caption{Overview of known and computed trajectory parameters}
    \label{tab:parameters}
    \begin{tabular}{@{}lllll@{}}
    \toprule
                & Known    & Obtained from & Computed & Method \\
                &          & user command  &          &        \\ \midrule
    Time-based  &
        $t_0$, $\th_0$, $\w_0$ &
        $\abs{\a_0}$, $\abs{\a_2}$, $\wt$, $t_3$, $\w_3$ &
        $\a_0$, $\a_2$, $t_1$, $t_2$, $\th_1$, $\th_2$, $\boldsymbol{\th_3}$
        & Section \ref{sec:timebasedref}\\
    Angle-based &
        $t_0$, $\th_0$, $\w_0$ &
        $\abs{\a_0}$, $\abs{\a_2}$, $\wt$, $\th_3$, $\w_3$ &
        $\a_0$, $\a_2$, $t_1$, $t_2$, $\boldsymbol{t_3}$, $\th_1$, $\th_2$ &
        Section \ref{sec:anglebasedref}  \\
        \bottomrule
    \end{tabular}
\end{table}

For a typical single command, the final speed is always zero ($\w_3 = 0$), in
which case $\th(t) \equiv \th_3$ for $t > t_3$. We will also allow the user to
specify $\w_3 = \wt$. This can be used to blend subsequent commands together
without stopping.


\subsection{Calculating trajectory parameters given time target}
\label{sec:timebasedref}
This section derives the parameters in Table \ref{tab:parameters} for a
time-based maneuver. Without loss of generality, we will assume that the
target angular velocity is nonnegative:
%
\begin{align}
    \label{eq:t:forwardmaneuver}
    \wt \geq 0, \quad \w_3 \in \{0, \wt\}
\end{align}
%
If it is not, we can mirror the inputs along the $\w=0$ line, perform the
following computations, and mirror back the final result. This is discussed
in Section \ref{sec:t:reversing}.

In a time-based maneuver, we are only concerned with angular velocity control,
while the final angle is arbitrary. In principle, this means we are only
concerned with tracking $\wref(t)$ as shown in the top graph of
Figure \ref{fig:plots}. However, that graph depicts only one possible angular
velocity trajectory, for a particular set of parameters.
Figure \ref{fig:time} captures four possible types of angular velocity
reference trajectories, which differ in initial speed compared to the
target speed and final speed.

\begin{figure}[H]
    \centering
    \includesvg[width=0.8\textwidth]{timebased}
    \caption{
        Time-based motions with a duration of $t_3-t_0$ for various initial
        conditions, with a stationary endpoint (left), or a nonzero final speed
        (right). The trajectory is determined by the initial speed $\w_0$,
        which may be equal to or greater than the target $\wt$ (blue),
        or lower than the target (green). It could also be so low or high that
        it will not be able to reach the target speed before completion
        (orange and red).\label{fig:time}}
\end{figure}

Because we allow only positive duration arguments, we have $t_3-t_0 > 0$ by
definition. In order to ensure that the motor is able to reach $\w_3$ at time
$t_3$, the initial angular velocity must be bound by the gray area in Figure
\ref{fig:time}. The slope magnitude of the upper boundary equals the magnitude
of the acceleration $\abs{\a_0}$ or deceleration $\abs{\a_2}$, whichever is
larger. The lower boundary slope corresponds to the acceleration magnitude
$\abs{\a_0}$. We also limit the target speed such that it is able to
decelerate to the final speed with the given deceleration $\a_2$. This gives
the constraints
%
\begin{align}
    -\abs{\a_0} \lr{t_3-t_0} &\leq \w_0 \leq \max \{\abs{\a_0}, \abs{\a_2}\} \lr{t_3-t_0} + \w_3\label{eq:t:timeboundary1}\\[1em]
    0 &\leq \wt \leq \abs{\a_2} \lr{t_3-t_0} + \w_3\nonumber
\end{align}
%
In all cases, the trajectory decelerates between $t_2$ and $t_3$, so that
$\a_2  = - \abs{\a_2} < 0$. The initial acceleration between $t_0$ and $t_1$
depends on the initial speed $\w_0$ with respect to the \mbox{target $\wt$},
which gives
%
\begin{align}
    \label{eq:t:accel0}
    \a_0 &= 
        \begin{cases}
        \phantom{-}\abs{\a_0} & \text{if} \quad \w_0 < \wt\\ 
        -\abs{\a_0} &  \text{otherwise}
        \end{cases}
\end{align}
%
The case of equality is handled intrinsically within the
second case by ensuring that $\a_0$ is never used if $\w_0 = \wt$.


\subsubsection{Standard case}
\label{sec:t:standard}
The first step is to accelerate or decelerate to reach the target speed $\wt$.
Solving for the intersection time $t_1$ gives:
%
\begin{align}
    \label{eq:t:t1mt0:standard}
    \lr{t_1 - t_0}\sub{standard} &= \dfrac{\wt-\w_0}{\a_0}
\end{align}
%
Similarly, the time $t_2$ at which we start decelerating becomes defined by:
%
\begin{align}
    \label{eq:t:t3mt2:standard}
    \lr{t_3 - t_2}\sub{standard} &= \dfrac{\w_3-\wt}{\a_2}\\[1em]
    \label{eq:t:t2mt1:standard}
    \lr{t_2 - t_1}\sub{standard} &=
        (t_3-t_0) - \lr{t_1 - t_0}\sub{standard} - \lr{t_3 - t_2}\sub{standard}
\end{align}
%
Since the target speed is reached the constant speed value is simply
\begin{align}
    \lr{\w_1}\sub{standard} &= \wt
\end{align}
%
The result is valid if and only if $\lr{t_2 - t_1}\sub{standard}\geq 0$.
Otherwise, we resort to the cut-short case covered below.

\subsubsection{Cut short case}
\label{sec:t:cutshort}
If the initial velocity is too low or if the maneuver is too short to be able
to reach the target velocity, it accelerates until it must begin to
decelerate, as shown by the first segment of the red line in Figure
\ref{fig:time}. Solving for the intersection time $t_1$
gives:
%
\begin{align}
    \label{eq:t:t1mt0:cutshort}
    \lr{t_1 - t_0}\sub{cut short} &=
        \dfrac{\w_3-\w_0 - \a_2(t_3-t_0)}{\a_0-\a_2}
\end{align}
%
This result also applies if the initial acceleration is negative (orange line).
Zero division would occur if $\a_2 = \a_0$. Since $\a_2 < 0$, this is a concern
only when $\a_0 < 0$. However, this never happens since $\a_2 = \a_0 < 0$
implies that the standard case in Section \ref{sec:t:standard} has a valid
solution.

Similarly, the time when we start decelerating ($t_2$) becomes defined by:
%
\begin{align}
    \label{eq:t:t3mt2:cutshort}
    \lr{t_3 - t_2}\sub{cut short} &= (t_3 - t_0) - (t_1 - t_0)\sub{cut short}
    \\[1em]
    \label{eq:t:t2mt1:cutshort}
    \lr{t_2 - t_1}\sub{cut short} &= 0
\end{align}
%
When cut short, the target speed $\wt$ is not reached but it peaks out at
%
\begin{align}
    \lr{\w_1}\sub{cut short} &= \w_0 + \a_0(t_1 - t_0)\sub{cut short}
\end{align}

\subsubsection{Cut short case with $\w_3 = \w_1$ and $\a_0 > 0$}
\label{sec:t:cutshortw3}

If $\w_3 = \wt$ and $\a_0 > 0$, there is only the increasing
ramp for the whole duration of the maneuver, indicated by the
red line in the right graph of Figure \ref{fig:time}, giving:
%
\begin{align}
    \w_1 = \w_3 := \w_0 + \a_0(t_3 - t_0)
\end{align}
%
and accordingly $t_3=t_2=t_1$.




\subsubsection{Reversing and unreversing the final and target speed}

\label{sec:t:reversing}
The aforementioned derivation assumes $\wt \geq \w_3 \geq 0$
\eqref{eq:t:forwardmaneuver} to reduce the number of (similar) cases that must
be accounted for. This section shows how to transform a given time based
maneuver to match this assumption, calculate the trajectory, and map the final
result back to obtain the originally requested command.

\begin{itemize}
    \item Cap $\w_0$ and $\wt$ using \eqref{eq:t:timeboundary1}.
    \item Let the boolean $a := \wt < 0$.
    \item If $a$, then invert all speeds: $\w_0 := -\w_0$, $\wt := -\wt$,
        $\w_3 := -\w_3$.
    \item Calculate time and speed intersections using Sections \ref{sec:t:standard}--
    \ref{sec:t:cutshortw3}.
    \item If $a$, then invert the results as shown in Section \ref{sec:invert}.
\end{itemize}


\subsubsection{Intermediate angles (all cases)}

Having derived expressions to evaluate $t_1$, $t_2$, and $\w_1$, the remaining
parameters of Table \ref{tab:parameters} to compute are the angles
$\th_1$, $\th_2$, and $\th_3$, which can be derived by integrating the
angular velocity reference signal \eqref{eq:thref}:
% %
\begin{align}
    \label{eq:t:anglepar1}
    \th_1  &= \th_0  + \w_0(t_1-t_0)+\dfrac{1}{2}\a_0(t_1-t_0)^2\\
    \label{eq:t:anglepar2}
    \th_2&=\th_1+ \w_1(t_2-t_1)\\
    \label{eq:t:anglepar3}
    \th_3  &=\th_2+ \w_2(t_3-t_2)+\dfrac{1}{2}\a_2(t_3-t_2)^2    
\end{align}
%

\subsection{Calculating trajectory parameters given angle target}
\label{sec:anglebasedref}
This section derives the parameters in Table \ref{tab:parameters} for an
angle-based maneuver. For simplicity of the derivation will assume that
the target angle  is greater than the initial angle. This
means that the motor must move forward to reach its goal:
%
\begin{align}
    \label{eq:a:forwardmaneuver}
    \th_3 &> \th_0\\
    \wt &> 0
\end{align}
%
If it is not, we can mirror the inputs along the $\th_3$ line, perform the
following computations, and mirror back the final result. This is discussed
in Section \ref{sec:a:reversing}.

In an angle-based maneuver, the end time $t_3$ is arbitrary, so the trajectory
is best analyzed in a ($\th$, $\w$) phase plot. This is shown in Figure
\ref{fig:positions} for various initial conditions indicated with blue dots.
To reduce the complexity of quadratic solutions on the microcontroller, we
restrict the final velocity to be either $\w_3=0$ or $\w_3=\w_2=\w_1$, implying
either deceleration to zero or no deceleration at all. Possible end states are
indicated with orange dots. In all cases $\a_2 < 0$.


\begin{figure}[H]
    \centering
    \includesvg[width=1\textwidth]{angbased}
    \caption{
        Phase portrait of trajectory from different types of initial conditions
        indicated with blue dots:
        (a) nonnegative initial speed with a
        sufficient distance from target to have a constant speed phase.
        (b) Same as (a), except with negative initial speed.
        (c) nonnegative initial speed without a constant speed phase because
        the target is too close.
        (d) Same as (c), except with negative initial speed.
        \label{fig:positions}}
\end{figure}


The typical trajectory is similar to case (a) and (c): The motor starts
with a nonnegative velocity, accelerates, optionally runs through a constant
speed phase, and then decelerates to standstill at the target.
If the initial speed is negative ($\w_0 < 0$) as in initial conditions (b)
and (d), the motor slows down and goes backwards in the process. Once the
velocity passes through zero, the remaining trajectory is just like case (a)
and (c). For all trajectory types, it is convenient to define the common
zero-speed angle $\th_f$ as indicated
with green dots in Figure~\ref{fig:positions}:
%
\begin{align}
    \th_f = \th_0 - \dfrac{1}{2 \a_0}\w_0^2
\end{align}

Because we allow only positive speeds we have $\th_3-\th_0 > 0$ by
definition. In order to ensure that the motor is able to reach $\w_3$ at time
$t_3$, the initial angular velocity must be bound by the gray area in Figure
\ref{fig:positions}. The upper boundary corresponds to the maximum speed
we can be at initially and still decelerate to the target angle on time.

In particular, we restrict the initial speed to the value from which we can
decelerate with either $\abs{\a_0}$ or $\abs{\a_2}$, whichever is larger.
There is no need for a negative lower bound. To see this, consider cases (b)
and (d) in Figure~\ref{fig:positions}: a negative initial speed makes it move
farther from the target angle, eliminating the risk of overshooting it. This
gives the constraint:
%
\begin{align}
    \w_0 \leq \sqrt{\w_3^2 + 2 \max\{ \abs{\a_0}, \abs{\a_2}\}\lr{\th_3-\th_0}}
\end{align}
%
Likewise, we bind the strictly positive target speed to a value from which we
can still decelerate to the final speed with the given deceleration
$\abs{\a_2}$:
%
\begin{align}
    0 < \wt \leq \sqrt{\w_3^2 + 2\abs{\a_2}\lr{\th_3-\th_0}}
\end{align}
%

In all cases, the trajectory decelerates between $t_2$ and $t_3$, so that
$\a_2  = - \abs{\a_2} < 0$. The initial acceleration between $t_0$ and $t_1$
depends on the initial speed $\w_0$ with respect to the \mbox{target $\wt$},
which gives
%
\begin{align}
    \label{eq:a:accel0}
    \a_0 &= 
        \begin{cases}
        \phantom{-}\abs{\a_0} & \text{if} \quad \w_0 < \wt\\ 
        -\abs{\a_0} &  \text{otherwise}
        \end{cases}
\end{align}
%
The case of equality is handled intrinsically within the
second case by ensuring that $\a_0$ is never used if $\w_0 = \wt$.



\subsubsection{Standard case with $\w_3 \in \{0, \wt\}$}
\label{sec:a:standard}
In the standard maneuver, it accelerates or decelerates
until it reaches the target speed $\w_1$, as shown for cases (a), (b), (c),
(d), and (e) in Figure \ref{fig:positions}. 
Solving for the intersection with $\wt$ gives:
%
\begin{align}
    \label{eq:a:t1mt0:standard}
    \lr{\th_1}\sub{standard} &= \th_f  + \dfrac{1}{2\a_0}(\wt)^2\\[1em]
    \lr{\th_2}\sub{standard} &= \th_3  + \dfrac{1}{2\a_2}\lr{(\wt)^2 - \w_3^2}
\end{align}
%
%
Since the target speed is reached the constant speed value is simply
\begin{align}
    \lr{\w_1}\sub{standard} &= \wt
\end{align}
%
The standard case is valid if and only if:
\begin{align}
    \label{eq:a:t1mt0:standardvalidity}
    \lr{\th_1}\sub{standard} &< \lr{\th_2}\sub{standard}
\end{align}
%
Otherwise, we have to evaluate the cut-short case.
%

\subsubsection{Cut short case with $\w_3 = 0$}
\label{sec:a:cutshortw3is0}
If initial velocity is too low or if the
maneuver is too short to be able to reach the target velocity, it accelerates
until it must begin to decelerate, as in cases (c) and (d) in
Figure \ref{fig:positions}.
Solving for the intersection angle $\th_1=\th_2$ for $\w_1=\w_2$ gives:
%
\begin{align}
    \label{eq:a:cutshort}
    \lr{\th_1}\sub{cut short} &= \lr{\th_2}\sub{cut short}\\[1em]
    \dfrac{1}{2\a_0}\w_1^2 + \th_f  &= \th_3 + \dfrac{1}{2\a_2} \w_1^2 
\end{align}
%
which can be solved for $\w_1$ as:
%
\begin{align}
    \label{eq:a:cutshortsolve}
    \w_1^2 = 2 \dfrac{\a_0\a_2}{\a_2-\a_0}\lr{\th_3 - \th_f}
\end{align}
%
from which $\th_1=\th_2$ follow via \eqref{eq:a:cutshort}:
%
\begin{align}
    \label{eq:a:cutshortr}
    \lr{\th_1}\sub{cut short}
    &=\th_f + \dfrac{\a_2}{\a_2-\a_0}\lr{\th_3 - \th_f}
\end{align}
%
When cut short, the target speed $\wt$ is not reached but the
peak $\w_1 \geq 0$ can be obtained as the square root
of \eqref{eq:a:cutshortsolve}.
%
\subsubsection{Cut short case with $\w_3 = \w_1$ and $\a_0 > 0$}
\label{sec:a:cutshortw3isw1}

If $\a_0 > 0$ and there is no deceleration phase but we still can't reach the
target speed, we have $\w_3=\w_1 < \wt$ with $\th_1=\th_2=\th_3$:
%
\begin{align}
    \label{eq:a:cutshortw1}
    \w_1^2  &= 2\a_0\lr{\th_3 - \th_f}
\end{align}

\subsubsection{Reversing and unreversing the final and target speed}
\label{sec:a:reversing}
The aforementioned derivation assumes $\th_3 > \th_0$ and so $\wt > 0$ to
reduce the number of (similar) cases that must be accounted for. This section
shows how to transform a given angle based maneuver to match this assumption,
calculate the trajectory, and map the final result back to obtain the
originally requested command.

\begin{itemize}
    \item Let the boolean $a := \th_3 < \th_0$.
    \item If $a$, then invert targets as:
          $\th_3 := 2 \th_0 - \th_3$, $\wt := -\wt$, $\w_0 := -\w_0$,
          $\w_3 := -\w_3$.
    \item Calculate angle and speed intersections using
          Sections \ref{sec:a:standard}--\ref{sec:a:cutshortw3isw1}.
    \item If $a$, then reverse results using Section \ref{sec:invert}.
\end{itemize}


\subsubsection{Intermediate times (all cases)}

Having derived expressions to evaluate $\th_1$, $\th_2$, and $\w_1$, the
remaining parameters of Table \ref{tab:parameters} to compute are the times
$t_1$, $t_2$, and $t_3$:
%
\begin{align}
    t_1 - t_0 &= \dfrac{\w_1-\w_0}{\a_0}\\[1em]
    t_2 - t_1 &= \dfrac{\th_2-\th_1}{\w_1}\\[1em]
    t_3 - t_2 &= \dfrac{\w_3-\w_1}{\a_2}
\end{align}

\subsection{Making a stationary trajectory}
\label{sec:stationary}
For a stationary hold trajectory, we have:
%
\begin{align}
    t_3 = t_2 = t_1 = t_0 \\[1em]
    \th_3 = \th_2 = \th_1 = \th_0 \\[1em]
    \w_1 = \w_0 = 0 \\[1em]
    \a_0 = \a_2 = 0
\end{align}


\subsection{Reversing a trajectory}
\label{sec:invert}
In Sections \ref{sec:timebasedref} and \ref{sec:anglebasedref} several
assumptions were made to ensure that the calculated trajectory is always
forwards with $\wt > 0$. If the original target speed was negative, the
newly computed maneuver can be reversed as follows:
%
\begin{align}
    \th_1 &:= 2 \th_0 - \th_1\\[1em]
    \th_2 &:= 2 \th_0 - \th_2\\[1em]
    \th_3 &:= 2 \th_0 - \th_3\\[1em]
    \w_0 &:= -\w_0\\[1em]
    \w_1 &:= -\w_1\\[1em]
    \a_0 &:= -\a_0\\[1em]
    \a_2 &:= -\a_2
\end{align}

\subsection{Stretching trajectories for synchronization}

In some applications, two or more separate trajectories are executed in
parallel to synchronize their movements. Typically, each trajectory has its own
target angle $\th_3$. To make them run in parallel, we slow down the shorter
maneuvers such that they take as long as the longest maneuver. For this
analysis, let the trajectory with superscript $0$ take the longest, so that
%
\begin{align}
    t^0_3 - t^0_0 \geq t^i_3 - t^i_0  \quad \forall \quad i
\end{align}

For synchronization we require that for all other trajectories $i$ we have:
%
\begin{align}
    t^i_1 &= t^0_1=t_1\\[1em]
    t^i_2 &= t^0_2=t_2\\[1em]
    t^i_3 &= t^0_3=t_3
\end{align}
%
Each trajectory still has to reach its own target $\th^i_3$.
Using (\ref{eq:t:anglepar1}--\ref{eq:t:anglepar3}) this gives the constraint:
%
\begin{align}
    \label{eq:stretchconstraint1}
    \th^i_3 - \th^i_0  &=  \w^i_0(t_1-t_0)+\dfrac{1}{2}\a^i_0(t_1-t_0)^2+
        \w^i_1(t_2-t_1)+ \w^i_1(t_3-t_2)+\dfrac{1}{2}\a^i_2(t_3-t_2)^2    
\end{align}
%
Likewise, each trajectory has to reach its top speed $\w^i_1$ and its final
speed $\w^i_3$ in the same time spans as the longest maneuver, which gives the
two additional constraints:
%
\begin{align}
    \label{eq:stretchconstraint2}
    \a^i_0 &= \dfrac{\w^i_1-\w_0^i}{t_1 - t_0}\\[1em]
    \label{eq:stretchconstraint3}
    \a_2^i &= \dfrac{\w_3^i-\w_1^i}{t_3 - t_2}
\end{align}
%
With three constraints we can solve for the three unknowns $\a^i_0$, $\a^i_1$.
and $\w^i_1$. To do so, solve for $\w^i_1$ by substituting
\eqref{eq:stretchconstraint2}, \eqref{eq:stretchconstraint3} into
\eqref{eq:stretchconstraint1}:
%
\begin{align}
    \label{eq:stretchconstraintsolved}
    \w^i_1 = \dfrac{2\lr{\th_3^i-\th_0^i}-\w_0^i\lr{t_1-t_0} -
    \w_3^i\lr{t_3-t_2}}{t_3-t_0 + t_2 - t_1}
\end{align}
%
Since $t_2 - t_1 \geq 0$, zero division is avoided if $t_3 - t_0 > 0$. If $t_3
- t_0 = 0$, then we have a stationary trajectory as per Section
\ref{sec:stationary}. If $\w_3^i$ was nonzero, it needs to be lowered
too as $\w_3^i := \w_1^i$.

Once $\w^i_1$ is known, $\a^i_0$, $\a^i_1$ follow directly from
\eqref{eq:stretchconstraint2}, \eqref{eq:stretchconstraint3}. Zero division is
avoided because $\a^i_0$ is undefined (not used) when $t_1 = t_0$ and $\a^i_2$
is undefined (not used) when $t_3 = t_2$. The intermediate angles $\th_1^i$
and $\th_2^i$ can be obtained from
(\ref{eq:t:anglepar1}--\ref{eq:t:anglepar2}).

\end{document}
